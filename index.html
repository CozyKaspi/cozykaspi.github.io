<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>F1 2025 Schedule — Oslo time</title>
<style>
html,body{margin:0;padding:0;height:100%;background:#0d1b2a;color:#fff;font-family:Arial,Helvetica,sans-serif;}
.container{box-sizing:border-box;padding:1vh;max-width:900px;margin:0 auto;overflow:auto;height:100%;}
.race{margin:0.5vh 0;padding:0.7vh;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);}
.race-title{font-weight:700;font-size:2.4vh;margin-bottom:0.4vh;}
.race-meta{font-size:1.6vh;opacity:0.9;margin-bottom:0.4vh;}
.session{display:flex;justify-content:space-between;font-size:1.6vh;padding:0.2vh 0;border-bottom:1px solid rgba(255,255,255,0.04);line-height:1.1;}
.session:last-child{border-bottom:none;}
.highlight{border:3px solid #ffeb3b;background:rgba(255,235,59,0.08);}
.past{opacity:0.6;}
.footer{font-size:1.2vh;text-align:right;margin-top:1vh;opacity:0.8;}
.error{color:#ff8a80;margin:1vh 0;}
</style>
</head>
<body>
<div class="container" id="schedule">Loading schedule…</div>
<div class="footer" id="updated"></div>

<script>
/* ---------- Utility: convert a local session (YYYY-MM-DDTHH:mm) in an IANA timezone
   to an instant (Date) in the local machine (Oslo browser), preserving DST.
   Approach:
   - Build the local date/time string without offset, then ask Intl to format that
     same wall time in the IANA zone into an absolute epoch by using Date parsing
     of an ISO string with offset computed via Intl.
   This is a practical approach without external libs and works in browsers with
   up-to-date Intl time zone support.
*/

function pad(n){ return (n<10?'0':'')+n; }

// Returns a Date object (instant) corresponding to the given local wall time expressed in "tz" IANA zone.
// localIsoNoOffset = "2025-09-19T13:30:00" (no offset)
// tz = "Asia/Baku"
function localWallTimeToInstant(localIsoNoOffset, tz) {
  // We'll ask Intl to format the same wall-time in the given timezone to find the UTC offset.
  // Create a Date object using the localIsoNoOffset as if it's in UTC (safe placeholder)
  // then compute the offset between the wall time and UTC by formatting.
  // This method is robust enough for modern browsers.
  // Step 1: split to components
  var parts = localIsoNoOffset.split(/[:T-]/).map(function(x){return parseInt(x,10);});
  // parts => [YYYY, MM, DD, HH, mm, ss]
  var year = parts[0], month = parts[1], day = parts[2], hour = parts[3]||0, minute = parts[4]||0, second = parts[5]||0;

  // Build an object for Intl
  var f = new Intl.DateTimeFormat('en-US', {
    timeZone: tz,
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
    hour12: false
  });

  // To determine the offset, we can search for an epoch that when displayed in 'tz' has the same wall time.
  // We'll binary search over a small time window: pick the approximate epoch by creating a Date using the same components in UTC
  var approx = Date.UTC(year, month-1, day, hour, minute, second);

  // Now get the formatted parts for that instant in the requested tz
  var partsObj = f.formatToParts(new Date(approx));
  function getVal(name){
    for(var i=0;i<partsObj.length;i++){ if(partsObj[i].type===name) return partsObj[i].value; }
    return '';
  }
  var tzYear = parseInt(getVal('year'),10);
  var tzMonth = parseInt(getVal('month'),10);
  var tzDay = parseInt(getVal('day'),10);
  var tzHour = parseInt(getVal('hour'),10);
  var tzMinute = parseInt(getVal('minute'),10);
  var tzSecond = parseInt(getVal('second'),10);

  // The wall time difference between approx (interpreted as UTC) and tz-formatted time gives us an offset
  var approxWallMillis = Date.UTC(tzYear, tzMonth-1, tzDay, tzHour, tzMinute, tzSecond);
  var diff = approx - approxWallMillis; // milliseconds to add to convert tz-wall to epoch

  // So to get the epoch for the requested wall time in tz, compute:
  // epoch = Date.UTC(year,month-1,day,hour,minute,second) - diff
  var desiredWallUtc = Date.UTC(year, month-1, day, hour, minute, second);
  var epoch = desiredWallUtc - diff;

  return new Date(epoch);
}

// Format a Date (instant) into Oslo time string "YYYY-MM-DD HH:mm"
function formatInOslo(d) {
  if(!d) return "";
  var options = {
    timeZone: 'Europe/Oslo',
    year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', hour12:false
  };
  var f = new Intl.DateTimeFormat('en-GB', options);
  // Format returns dd/mm/yyyy, hh:mm:ss — we'll recompose using formatToParts for reliable ordering
  var parts = f.formatToParts(d);
  var map = {};
  for(var i=0;i<parts.length;i++){ if(parts[i].type) map[parts[i].type]=parts[i].value; }
  return map.year + '-' + map.month + '-' + map.day + ' ' + map.hour + ':' + map.minute;
}

/* ---------- Load races.json and render ---------- */
function loadAndRender() {
  var scheduleDiv = document.getElementById('schedule');
  scheduleDiv.innerHTML = 'Loading races...';

  fetch('races.json', {cache:'no-store'}).then(function(resp){
    if(!resp.ok) throw new Error('Failed to fetch races.json: ' + resp.status);
    return resp.json();
  }).then(function(data){
    // Convert each session local wall time to an instant, then to Oslo for display
    var now = new Date();
    // classify races
    var past = [], upcoming = [], current = null;

    for(var i=0;i<data.length;i++){
      var r = data[i];
      // convert sessions to instants (Date objects)
      var instants = [];
      for(var j=0;j<r.sessions.length;j++){
        var s = r.sessions[j];
        // localDateTime is like "2025-09-19T13:30:00"
        try {
          var instant = localWallTimeToInstant(s.localDateTime, r.timezone);
        } catch (e) {
          console.error('convert error', e, r.title, s);
          var instant = new Date(s.localDateTime); // fallback — may be wrong if no offset
        }
        instants.push({session:s, instant:instant});
      }

      // find P1 and Race session instants
      var p1i = null, racei = null;
      for(var k=0;k<instants.length;k++){
        if(instants[k].session.name === 'P1') p1i = instants[k].instant;
        if(instants[k].session.type === 'race-event' || instants[k].session.name === 'Race') racei = instants[k].instant;
      }

      // Determine status using the rule: current if now >= P1_in_oslo and now <= Race_in_oslo + 2h
      if(p1i && racei) {
        var raceEndBuffer = new Date(racei.getTime() + 2*60*60*1000);
        if(now >= p1i && now <= raceEndBuffer) {
          current = {race:r, instants:instants};
        } else if(now < p1i) {
          upcoming.push({race:r, instants:instants});
        } else {
          past.push({race:r, instants:instants});
        }
      } else {
        // fallback: upcoming
        upcoming.push({race:r, instants:instants});
      }
    }

    // Sort upcoming by round if available
    upcoming.sort(function(a,b){ return (a.race.round||0) - (b.race.round||0); });
    past.sort(function(a,b){ return (a.race.round||0) - (b.race.round||0); });

    // Render
    scheduleDiv.innerHTML = '';
    function renderRaceBlock(obj, cls, isHighlight) {
      var r = obj.race;
      var instants = obj.instants;
      var wrap = document.createElement('div');
      wrap.className = 'race' + (cls ? ' '+cls : '') + (isHighlight ? ' highlight' : '');
      var title = document.createElement('div'); title.className = 'race-title'; title.textContent = r.title;
      var meta = document.createElement('div'); meta.className = 'race-meta'; meta.textContent = r.location + ' • ' + r.track + ' • ' + r.dates;
      wrap.appendChild(title); wrap.appendChild(meta);
      for(var s=0;s<instants.length;s++){
        var item = instants[s];
        var sessionDiv = document.createElement('div');
        sessionDiv.className = 'session';
        // session name and time in Oslo
        var nameSpan = document.createElement('span'); nameSpan.textContent = item.session.name;
        var timeSpan = document.createElement('span'); timeSpan.textContent = formatInOslo(item.instant) + ' (Oslo)';
        sessionDiv.appendChild(nameSpan); sessionDiv.appendChild(timeSpan);
        wrap.appendChild(sessionDiv);
      }
      scheduleDiv.appendChild(wrap);
    }

    if(current) renderRaceBlock(current, '', true);
    for(var ui=0; ui<upcoming.length; ui++) renderRaceBlock(upcoming[ui], '');
    for(var pi=0; pi<past.length; pi++) renderRaceBlock(past[pi], 'past');

    // updated footer
    var upd = document.getElementById('updated');
    var d = new Date();
    upd.textContent = 'Last checked: ' + d.toLocaleString();
  }).catch(function(err){
    var scheduleDiv = document.getElementById('schedule');
    scheduleDiv.innerHTML = '<div class="error">Error loading schedule: ' + (err.message||err) + '</div>';
    console.error(err);
  });
}

// initial load
loadAndRender();
// re-evaluate every 60s
setInterval(loadAndRender, 60000);
</script>
</body>
</html>
